<div id="sect_title_img_3_6"></div>

<div id="sect_title_text"></div>

# オーディオファイルを再生する

<div id="preface"></div>

###### 本節ではBlenderが提供するオーディオファイルの再生支援モジュールであるaudモジュールを使って、オーディオファイルを再生する方法を説明します。3DCGを作成するBlenderのアドオンではオーディオファイルを扱うことはほとんどないと思いますが、こういうアドオンもあるのだという気持ちで読んでもらえればと思います。


## 作成するアドオンの仕様

* *3Dビュー* エリアのツール・シェルフに *オーディオ再生* パネルを追加し、選択したオーディオファイルを再生する簡易オーディオプレイヤーを作成する
* オーディオプレイヤーは以下の機能を持つ
  * 選択したファイルの再生・一時停止・一時停止解除・停止
  * ループ再生
  * 音量変更
  * ピッチ変更

## アドオンを作成する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考にして以下のソースコードをテキスト・エディタに入力し、ファイル名 ```sample_3-6.py``` として保存してください。

[import](../../sample/src/chapter_03/sample_3-6.py)

## アドオンを使用する

### アドオンを有効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に作成したアドオンを有効化すると、コンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-6: アドオン「サンプル3-6」が有効化されました。
```

また、*3Dビュー* エリアのツール・シェルフに *オーディオ再生* パネルが追加されます。

### アドオンの機能を使用する

以下の手順に従って、作成したアドオンの機能を使ってみます。

<div id="process_title"></div>

##### Work

<div id="process"></div>

|<div id="box">1</div>|*3Dビュー* エリアのツール・シェルフから *オーディオ再生* パネルを選択します。||
|---|---|---|

<div id="process_sep"></div>

---

<div id="process"></div>

|<div id="box">2</div>|*オーディオファイルを選択* ボタンをクリックします。||
|---|---|---|

<div id="process_sep"></div>

---

<div id="process"></div>

|<div id="box">3</div>|ファイルブラウザが開くため、再生するオーディオファイルを選択して *オーディオファイルの選択* ボタンをクリックします。本節のサンプルでは、デフォルトで *.wav* 形式と *.mp3* 形式の2つの拡張子に絞って表示していますが、*ファイルのフィルタリングを有効化ボタン* をクリックすることで、他のファイルも選択できるようになります。||
|---|---|---|

<div id="process_sep"></div>

---

<div id="process"></div>

|<div id="box">4</div>|*再生* ボタンをクリックすると、オーディオファイルが再生されます。||
|---|---|---|

<div id="process_sep"></div>

---


<div id="process"></div>

|<div id="box">5</div>|*音量* や *ピッチ* を変更することに加え、オーディオファイルの再生一時停止やループ再生もできます。||
|---|---|---|

<div id="process_sep"></div>

---


<div id="process_start_end"></div>

---


### アドオンを無効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に有効化したアドオンを無効化すると、コンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-6: アドオン「サンプル3-6」が無効化されました。
```

## ソースコードの解説

本節のサンプルは、オーディオファイルの再生に加えて様々な機能を追加しているため、ソースコードの規模が大きくなっています。このため、最初にBlenderのAPIを使ったオーディオファイルの再生手順を説明した後、本節のサンプルの説明を行います。

### オーディオファイルの再生手順概要

Blenderが提供するAPIを使ってオーディオファイルを再生する手順を次に示します。

1. audモジュールをインポート
2. サウンドデバイスを作成
3. サウンドファクトリを作成
4. サウンドハンドラを作成（オーディオファイルを再生）


BlenderのAPIを使ってオーディオファイルを再生するためには、audモジュールをインポートする必要があります。

[import:"import_aud", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)


サウンドデバイスとサウンドファクトリは、```aud.device()``` 関数および ```aud.Factory()``` 関数を実行することで作成することができます。```aud.device()``` 関数は引数が不要ですが、```aud.Factory()``` 関数は再生するオーディオファイルのパスを引数に指定する必要があります。ここで、サウンドデバイスとサウンドファクトリという2つの用語が出てきましたが、これらは何を指しているのでしょうか？

サウンドデバイスはOpenALやSDLなどのサウンドライブラリで扱うデバイスのことを指し、オーディオを出力するために必要なものです。サウンドファクトリは複数の音源をミックスしたり、ハイパスフィルター（HPF）やローパスフィルター（LPF）などのエフェクトをかけたりするためのオブジェクトです。サウンドを編集する時に使うことがあるかもしれませんが、Blenderはあくまで3DCGソフトなので本節のサンプルではこれらの機能を使っていません。（筆者はサウンドプログラミングに興味があり、もう少し詳しく書きたいのですが、関係ない人には全く意味のない話題にページを割くのはやめました・・・）


最後に、```aud.device()``` の戻り値の ```play()``` メソッドに ```aud.Factory()``` の戻り値を引数に代入することで、サウンドハンドラが作成されてオーディオファイルが再生されます。サウンドハンドラは戻り値で取得でき、停止/一時停止/再生再開に加えて、ピッチやボリュームを変更するためのオブジェクトです。


### オーディオファイルの選択

再生するオーディオファイルを選ぶ処理は、```SelectAudioFile``` で行います。```SelectAudioFile``` は、[2-10節](../chapter_02/10_Control_Blender_UI_3.md) で説明したファイルブラウザを表示するための処理です。

ファイルブラウザの表示に関しては、[2-10節](../chapter_02/10_Control_Blender_UI_3.md) と同じですが1点だけ異なるところがあり、本節のサンプルではwavファイルとmp3のファイルしか表示されません。このように、特定のファイルのみを表示したい場合は ```filter_glob``` クラス変数を宣言します。```filter_glob``` は ```StringProperty``` クラスで定義し、```default``` に表示するファイルのリストを ```;``` （セミコロン）区切りで指定します。なお、正規表現を使うことができます。本節のサンプルでは全てのwavファイルとmp3ファイルを表示するため、```*.wav; *.mp3``` を指定しています。

[import:"filter_glob", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)

ファイル名指定でフィルタリングできるか確認すること。

ファイルブラウザでファイルを選択すると ```execute()``` メソッドが実行されます。

[import:"select_audio_file_execute", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)

処理の流れは、オーディオファイルの再生手順概要で示した通りです。サウンドデバイスは一度作成すればよいため、オーディオファイルの選択は複数回実行されることを想定し、サウンドデバイスが初回のみ作成されるようにしています。また、オーディオファイルを再生中である場合は停止する処理も追加しています。


### オーディオファイルの再生

オーディオファイルの再生は、```PlayAudioFile``` クラスの ```execute()``` メソッドで行います。

[import:"play_audio_file", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)

*再生* ボタンを押したときに呼び出される ```AudioDevice.device.play()``` 関数を実行することで、オーディオファイルを再生することができます。```AudioDevice.device.play()``` 関数の戻り値であるサウンドハンドラ ```AudioDevice.handle``` はメンバ変数を持ち、本節のサンプルでは以下のメンバ変数を使っています。これらのメンバ変数に値を代入することで、再生時の振る舞いを変更することができます。本節のサンプルでは、*再生* ボタンを押したときにツール・シェルフのプロパティの値で再生したいため、メンバ変数 ```volume```,```pitch```,```loop_count``` にプロパティの値を代入しています。

|メンバ変数|意味|
|---|---|
|```volume```|音量（最大1、最小0）|
|```pitch```|ピッチ（最小0）|
|```loop_count```|ループ回数（ループ回数を指定、ループ回数が0なら1回限りの再生、負の値なら無限ループ再生）|
|```position```|再生位置（単位は秒）|
|```status```|再生状態|

最後に ```bpy.ops.ui.audio_play_time_updater()``` を呼び出していますが、これにより再生時間を更新する処理のクラス ```AudioPlayTimeUpdater``` に記述した処理を実行します。オーディオファイルが再生中の時、```AudioDevice.handle.status``` には ```aud.AUD_STATUS_PLAYING``` が保存されています。


### 再生時間の更新

再生時間は ```AudioDevice.handle.position``` で取得できるため、パネルクラス ```VIEW3D_PT_PlayAudioFileMenu``` に定義されている ```draw()``` メソッド内の以下の処理で表示します。

[import:"display_play_time", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)

しかし ```layout.label``` でラベル表示しただけでは、ツール・シェルフで再描画イベントが発生するまで再生時間が止まってしまいます。このため、定期的に再描画イベントをツール・シェルフへ発行する必要があります。そこで、[3-3節](03_Handle_Timer_Event.md) で紹介した方法を使い、```AudioPlayTimeUpdater``` クラスでタイマイベントを発生させ、```modal()``` メソッド内の以下の処理で再描画イベントを発行します。

[import:"redraw_toolself", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)

以前のサンプルでは ```context.area.tag_redraw()``` 関数によりエリア全体を再描画しましたが、本節のサンプルではツール・シェルフのリージョンに対してのみ ```tag_redraw()``` 関数を実行することで、再描画イベントの発行先を少なくして描画コスト少なくしています。


### オーディオファイルの再生一時停止

オーディオファイルの再生を一時停止するためには、```AudioDevice.handle.pause()``` 関数を実行します。```PauseAudioFile``` クラスの ```execute()``` メソッドでは ```AudioDevice.paused``` に ```True``` を代入していますが、これはポーズ中であることを示すために行っています。なお、```AudioDevice.handle.status``` には```aud.AUD_STATUS_PAUSED``` が設定されることもあるようですが、実際に ```AudioDevice.handle.pause()``` 関数を実行しても ```aud.AUD_STATUS_PAUSED``` から状態が遷移しないため、本節のサンプルではポーズ中であることを示すためのフラグを追加しました。

オーディオファイルの再生を再開するためには、```AudioDevice.handle.resume()``` 関数を実行します。


### オーディオファイルの再生停止

オーディオファイルの再生が停止されるパターンは2通りあります。

* *停止* ボタンを押した
* チェックボックス *ループ再生* にチェックが入っていない状態で、オーディオファイルを最後まで再生した

*停止* ボタンを押した時にオーディオファイルの再生を停止する場合は、```AudioDevice.handle.stop()``` 関数を実行します。本関数を用いてオーディオファイルの再生を停止した場合、```AudioDevice.handle.status``` には ```aud.AUD_STATUS_STOPPED``` が設定されます。一方、オーディオファイルを最後まで再生して停止した場合は、```AudioDevice.handle.status``` には ```aud.AUD_STATUS_INVALID``` が代入されます。

再生停止時には、```AudioDevice.handle``` に ```None``` を代入することで、サウンドハンドラを破棄します。*停止* ボタンを押した時の処理は、```AudioDevice.handle.stop()``` 関数を呼び出した後にサウンドハンドラを破棄するのみで単純ですが、オーディオファイルを最後まで再生した時の処理が少し複雑です。タイマイベントが発行されると、```AudioPlayTimeUpdater``` の ```modal()``` メソッドは、*3Dビュー* エリアのツール・シェルフリージョンに再描画イベントを発行します。再描画イベントが発行されると、```VIEW3D_PT_PlayAudioFileMenu``` の ```draw()``` メソッド内で以下の処理が呼び出されます。

[import:"destroy_sound_handle", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)


### プロパティ変更の検知

本節のサンプルでは、*3Dビュー* エリアのツール・シェルフにある *オーディオ再生* パネルから音量・ピッチ・ループ再生の要否を検知し、即座にオーディオファイル再生へ反映しています。ここで気が付かれた方もいると思いますが、このような処理はどのように実現したらよいのでしょうか？本節より前に紹介したサンプルではプロパティの値を参照した後に処理を行う流れであるため困ることはありませんでしたが、オーディオファイルの場合は一度再生してしまうと再生処理がアドオンの処理の裏で行われてしまいます。つまり、常にプロパティの値を参照して反映する方法ではうまくいかないのです。

本節のサンプルのようにプロパティの値が変わったことを検知して処理を行いたい場合は、プロパティクラスを作成する時に引数 ```set``` と ```get``` に、プロパティが変わった時に実行する関数を登録する必要があります。音量を変更するプロパティの定義の処理を見てみましょう。

[import:"prop_volume", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)

引数 ```get``` に ```get_volume()``` 関数、引数 ```set``` に ```set_volume()``` 関数を指定しています。引数 ```set``` には、プロパティの値が変更された時に呼び出す関数を指定し、引数 ```get``` にはプロパティの値を参照する時に呼び出す関数を指定します。

最初に、```get_volume()``` 関数について説明します。

[import:"get_volume", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)

```get_volume()``` 関数は第1引数にプロパティクラスのインスタンスが代入された状態で呼び出されます。```get_volume()``` 関数はプロパティを参照する時に呼び出されるため、予期しない時に呼び出される可能性があります。このため、呼び出されるタイミングによっては参照したい変数が存在しないかもしれません。そこで ```self.get()``` メソッドの第2引数にデフォルト値を指定することで、第1引数に指定したインスタンス変数が存在しない場合はデフォルト値を返すような処理を行っています。

一方で ```set_volume()``` 関数は、第1引数にプロパティクラスのインスタンス、第2引数にプロパティに設定された値が渡されて呼び出されます。

[import:"set_volume", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-6.py)

```set_volume()``` 関数は、```self['paf_volume'] = value``` によりプロパティの値を更新した後、```AudioDevice.handle.volume``` に値を設定することで音量を変更しています。このような一連の処理を行うことで、ユーザからのプロパティ変更を検知し、オーディオファイルの再生音量を変更することができます。

ピッチやループ再生についても同様の方法で、ユーザによるプロパティ変更に応じて設定を変更することができます。


## まとめ

Blenderのaudモジュールを使ってオーディオファイルを再生する方法を説明しました。筆者がaudモジュールの存在を初めて知った時、3DCGソフトであるBlenderにオーディオファイルを扱うAPIが存在しているのが疑問で、本書の話題として取り上げるかどうかを迷っていました。しかし、[4-1節](../chapter_04/01_Research_official_Blender_API_for_Add-on.md) で紹介する公式のAPIリファレンスのStandaloneモジュールに含まれることから、場違いであることを承知の上で話題として取り上げました。音を扱うという意味ではGame Engine Modulesに記載されるべきであるのに、あえてStandaloneモジュールに含めた理由はわかりませんが、動画作成時にオーディオファイルを再生することも考えてゲームエンジンに限定しなかったのかもしれません。

本節のサンプルではオーディオファイルの再生/停止の処理に加え、音量やピッチなどのプロパティをユーザが変更したことを検知する方法を説明しました。[3-3節](03_Handle_Timer_Event.md) で扱ったタイマイベントやモーダルモードなど、前節までに説明した内容が盛りだくさんな内容となっています。本節で紹介したサンプルのように少しでも手の込んだ機能を実装するとなると、単一の機能だけを使うのではなく複数の機能を組み合わせることが重要になってきます。本節より後の章ではまた異なるAPIを紹介しますが、APIを知ってただ満足するのではなく、APIを組み合わせて何かできないかを考えるように心がけてみてください。

最後に、audモジュールはマイナーなモジュールのように見えて、ローパスフィルターやハイパスフィルター、ミックスなどサウンドプログラミングをする上で基本的な機能がAPIとして提供されています。扱いも非常に簡単なため、ぜひこの機会にBlenderでサウンドプログラミングに挑戦してみてはいかがでしょうか？


<div id="point"></div>

### ポイント

<div id="point_item"></div>

* オーディオファイルをアドオンで扱うためには、audモジュールをインポートする必要がある
* サウンドデバイスはサウンドを出力するために必要な、低レベルのサウンド再生デバイスである
* サウンドファクトリはオーディオファイルのデータにエフェクトをかけたりミックスしたりするために使うオブジェクトである
* サウンドハンドラはオーディオの再生制御を行うだけでなく、オーディオ再生の設定(音量やピッチなど)を参照/変更することができる
* プロパティクラスの値が参照された時に処理を実行したい場合は引数 ```get``` 、更新されたときに処理を実行したい場合は引数 ```set``` に処理を定義した関数を指定する
