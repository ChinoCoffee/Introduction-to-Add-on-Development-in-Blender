<div id="sect_title_img_3_5"></div>

<div id="sect_title_text"></div>

# blfモジュールを使ってテキストを描画する

<div id="preface"></div>

###### [3-4節](04_Use_API_for_OpenGL.md) ではOpenGLのAPIを利用した図形描画を行う方法を説明しましたが、本節のサンプルではテキストを描画する方法を説明します。本節では [3-3節](03_Handle_Timer_Event.md) のサンプルを改造したアドオンを用いて説明しますが、可能な限りテキスト描画の説明に閉じて説明しますので、必ずしも [3-3節](03_Handle_Timer_Event.md) をすべて理解する必要はありません。


## 作成するアドオンの仕様

* [3-3節](03_Handle_Timer_Event.md) を改造し、作業時間を *3Dビュー* エリアのウィンドウ左上部に表示する

## アドオンを作成する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考にして以下のソースコードをテキスト・エディタに入力し、ファイル名 ```sample_3-5.py``` として保存してください。

[import](../../sample/src/chapter_03/sample_3-5.py)

## アドオンを使用する

### アドオンを有効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に作成したアドオンを有効化すると、コンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-5: アドオン「サンプル3-5」が有効化されました。
```



### アドオンの機能を使用する

以下の手順に従って、作成したアドオンの機能を使ってみます。

<div id="process_title"></div>

##### Work

<div id="process"></div>

|<div id="box">1</div>|*3Dビュー* エリアのプロパティパネルの *作業時間計測* に配置されている *開始* ボタンを押すと、アクティブなオブジェクトに対する作業時間の計測が始まります。||
|---|---|---|

<div id="process_sep"></div>

---

|<div id="box">2</div>|作業時間を表示したいオブジェクトをコンボボックスから選択すると、選択したオブジェクトについてオブジェクトモードとエディットモードでの作業時間が、*3Dビュー* エリアのウィンドウ左上部に表示されます。||
|---|---|---|

<div id="process_sep"></div>

---

<div id="tips"></div>

[3-3節](03_Handle_Timer_Event.md) と同様、本節のサンプルでも作業時間計測後のオブジェクト名変更には対応していません。  
オブジェクト名を変更すると、名前変更後のオブジェクトが新たに追加されたものとして作業時間が計測されます。


|<div id="box">3</div>|*終了* ボタンを押すと、作業時間の計測が止まります。なお、計測を止めると同時に作業時間の表示が消えます。||
|---|---|---|

<div id="process_sep"></div>

---

<div id="process_start_end"></div>

---


### アドオンを無効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に有効化したアドオンを無効化すると、コンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-5: アドオン「サンプル3-5」が無効化されました。
```

## ソースコードの解説

本節のサンプルは、[3-3節](03_Handle_Timer_Event.md) のソースコードを改造したものであるため、改造した箇所を中心に説明します。

### テキスト描画APIを利用する

本節のサンプルでは、任意のテキストを描画するためにBlenderが提供するAPIを利用します。

テキストを描画するためのAPIをアドオンから利用するためには、```blf``` モジュールをインポートする必要があります。

[import:"import_blf", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-5.py)


### 描画関数を登録する

テキストを描画するためには、[3-4節](04_Use_API_for_OpenGL.md) で ```bgl``` モジュールを使って図形を描画した時と同様、描画関数を登録する必要があります。描画関数の登録は、```__handle_add()``` メソッド内の ```bpy.types.SpaceView3D.draw_handler_add()``` 関数で行ないます。具体的な引数の型などは、[3-4節](04_Use_API_for_OpenGL.md) と同じのため説明は省略します。

[import:"add_render_func", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-5.py)

本節のサンプルにおける描画関数は、```render_working_hours()``` スタティックメソッドです。


### 描画関数の処理

描画関数 ```render_working_hours()``` スタティックメソッドは描画先のリージョンを ```get_region()``` スタティックメソッドで取得した後、```render_message()``` スタティックメソッドを使って指定した座標に作業時間の計測結果を表示します。

#### リージョンの取得

[3-4節](04_Use_API_for_OpenGL.md) で説明したように、ウィンドウの座標は左下が (x, y) = (0, 0) でした。
本節のサンプルではウィンドウの左上に座標に表示する必要がありますが、左上の座標は環境によって変化するため単純に数値をそのまま入力して左上に表示されるように調整しただけでは、ウィンドウのサイズを変更した時にうまくいきません。このため、左上の座標を常に取得しておく必要があります。

ウィンドウの左上の座標を取得するためには、エリアを構成するリージョンを取得する必要があります。本節のサンプルでは以下のコードにより、リージョンを指定したリージョンを取得しています。

[import:"get_region", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-5.py)

現在開いているエリアの一覧は ```context.screen.areas``` で示されているため、```get_region()``` スタティックメソッドの引数に指定したエリアのタイプ ```area_type``` と ```area.type``` が一致を確認することで目的のエリアを取得することができます。本節のサンプルでは、```get_region()``` スタティックメソッドの引数 ```area_type``` に ```'VIEW_3D'``` が指定されているため、*3Dビュー* エリアを取得することができます。

取得したエリアから ```area.regions``` により、エリアを構成するリージョンの一覧を取得することができます。エリアと同様に ```region.type``` と ```get_region()``` スタティックメソッドの引数 ```region_type``` が一致すれば、目的のリージョンを取得することができます。本節のサンプルでは、 ```get_region()``` スタティックメソッドの引数 ```region_type``` に ```'WINDOW'``` が指定されているため、ウィンドウリージョンを取得することができます。


#### 描画座標の計算

ウィンドウリージョンは、```get_region()``` スタティックメソッドの戻り値 ```region``` に保存されています。```region``` からは、リージョンに関する情報を取得することができます。本節のサンプルでは、作業時間を描画する座標を求めるために ```region``` を利用します。

リージョンの左下の座標値が (x, y) = (0, 0) であることから、左上の座標は (x, y) = (0, リージョンの高さ) で求められそうです。```region``` はリージョンの高さや幅の情報を保持していて、```region.height``` でリージョンの高さを、```region.width``` でリージョンの幅を取得することができます。このため、リージョンの左上の座標は (x, y) = (0, region.height) で取得することができます。


#### 文字列の描画処理

文字列の描画処理は、```render_message()``` スタティックメソッドで行います。

[import:"render_message", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-5.py)

```render_message()``` の引数を以下に示します。

|引数|意味|
|---|---|
|```size```|フォントサイズ|
|```x```|描画座標（X座標）|
|```y```|描画座標（Y座標）|
|```msg```|描画する文字列|


文字列を描画するために、```blf``` モジュールの関数を3つ使っています。1つ目の ```blf.size()``` 関数では、フォントサイズを指定します。```blf.size()``` 関数には以下の引数を指定します。

|引数|意味|
|---|---|
|第1引数|フォントID（デフォルトのフォントを使う場合は、```0```を指定）|
|第2引数|フォントサイズ|
|第3引数|DPI|

次に ```blf.position()``` 関数を使って、文字列を描画する位置を指定します。```blf.position()``` 関数には以下の引数を指定します。

|引数|意味|
|---|---|
|第1引数|フォントID（デフォルトのフォントを使う場合は、```0```を指定）|
|第2引数|描画座標（X座標）|
|第3引数|描画座標（Y座標）|
|第4引数|描画座標（Z座標）|

最後に ```blf.draw()``` 関数により、文字列を描画します。```blf.draw()``` 関数の引数を以下に示します。

|引数|意味|
|---|---|
|第1引数|フォントID（デフォルトのフォントを使う場合は、```0```を指定）|
|第2引数|描画する文字列|


<div id="tips"></div>

フォントIDはBlenderに読み込まれているフォントの識別子で、デフォルトのフォントには0が割り当てられています。好きなフォントに変えたい場合は、 blf.load() 関数を使ってフォントを読み込み、フォントIDに blf.load() の戻り値を指定することで、読み込んだフォントを使って文字列を描画することができます。


描画関数である ```render_working_hours()``` スタティックメソッドでは、計算した描画座標を使い、```render_message()``` スタティックメソッドを呼びます。

[import:"call_render_region", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-5.py)


描画する文字列を組み立てるために ```make_time_fmt()``` スタティックメソッドを呼びだしていますが、[3-3節](03_Handle_Timer_Event.md) の ```__make_time_fmt()``` メソッドの処理と同じです。文字列 "Working Hour" は、```blf``` モジュールのフォント装飾機能を使って強調しています。

```blf.shadow()``` 関数は描画するテキストに影の効果を加えるための関数で、以下の引数を与えることで好みの影をつけることができます。本節のサンプルでは、影の色が緑色でアルファ成分が0.5、影の大きさが3の影をつけています。

|引数|意味|
|---|---|
|第1引数|フォントID（デフォルトのフォントを使う場合は、```0```を指定）|
|第2引数|影の大きさ|
|第3引数|影の色(赤成分)|
|第4引数|影の色(緑成分)|
|第5引数|影の色(青成分)|
|第6引数|影の色(アルファ値)|

```blf.shadow_offset()``` 関数により、影の表示位置も変更することができます。本節のサンプルでは、テキストの描画位置から右に2ピクセル、下に2ピクセルずらして影を表示するように設定しています。

|引数|意味|
|---|---|
|第1引数|フォントID（デフォルトのフォントを使う場合は、```0```を指定）|
|第2引数|テキスト本体からのオフセットピクセル数（X軸）|
|第3引数|テキスト本体からのオフセットピクセル数（Y軸）|


<div id="tips"></div>

blf.shadow_offset() 関数の第2引数は画面右方向がX軸正方向、第3引数は画面上方向が正方向です。リージョンのY座標の方向と異なるため、混乱しないように注意してください。


影の大きさや色、表示位置を設定しましたが、このままでは影が有効化されません。影を有効化するためには、```blf.enable()``` 関数の引数に ```blf.SHADOW``` を指定して呼び出す必要があることに注意してください。影を無効化する場合は ```blf.disable()``` 関数の引数に ```blf.SHADOW``` を指定して呼び出す必要があります。

```blf.enable()``` 関数は影の描画を有効化する以外にも、テキストの回転やテキストの一部分を切り出して表示する効果を有効化する際にも使われます。```blf.enable()``` に指定可能な値を以下に示します。

|値|効果|
|---|---|
|ROTATION|回転|
|CLIPPING|切り抜き|
|SHADOW|影|

文字列の回転量は ```blf.rotation()``` 関数に以下の引数を指定することで回転量を調整できます。

|値|効果|
|---|---|
|第1引数|フォントID（デフォルトのフォントを使う場合は、```0```を指定）|
|第2引数|回転量（ラジアン）|

文字列の切り抜きは ```blf.clipping()``` 関数に以下の引数を指定することで切り抜き領域を指定できます。なお切り抜き領域には、リージョンの左下を (x, y) = (0, 0) とした座標を指定することに注意が必要です。

|値|効果|
|---|---|
|第1引数|フォントID（デフォルトのフォントを使う場合は、```0```を指定）|
|第2引数|切り抜く領域のX座標の最小値|
|第3引数|切り抜く領域のY座標の最小値|
|第4引数|切り抜く領域のX座標の最大値|
|第5引数|切り抜く領域のY座標の最大値|


なお ```blf.enable()``` を有効化した効果は、描画関数を終える前に必ず無効化してください。無効化しないまま描画関数を終えてしまうと、Blender内のすべてのUI上に表示されているテキストに対して、```blf.enable()``` で設定した効果が適用されてしまいます。



### 描画関数の登録を解除する

[3-4節](04_Use_API_for_OpenGL.md) と同様に登録した描画関数は、描画処理を停止するときに登録を解除する必要があります。

[import:"remove_render_func", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-5.py)



## まとめ

Blenderが提供するテキスト描画モジュール ```blf``` を用いて、任意のテキストをBlender上に表示する方法を説明しました。

```blf``` モジュールを利用するためには、描画関数の登録やテキストに適用した効果の管理などの面倒な部分がありますが、[3-3節](03_Handle_Timer_Event.md) のサンプルで紹介したようにBlenderのUIへ表示するよりも描画方法に自由度があります。また、Blenderのアドオンの中には ```bgl``` モジュールと組み合わせることで一風変わったUIを構築しているアドオンが数多くあるため、いろいろなアドオンを触りつつソースコードを見ながら学んでいくとよいと思います。例えば、クリックしたマウスのボタンや押したキーボードのキーを表示するアドオン『Screencast Keys』は、```bgl``` モジュールや ```blf``` モジュールを使っており、取っ掛かりとしては良いと思います。


<div id="point"></div>

### ポイント

<div id="point_item"></div>

* Blenderが提供するテキストを描画するためのAPIは、```blf``` モジュールをインポートすることで利用可能になる
* ```blf``` モジュールを使ってテキストを描画するためには、```bgl``` モジュールを用いた描画処理と同様に ```bpy.types.SpaceXXX.draw_handler_add()``` （XXX：描画するエリア）関数を用いて、描画用のスタティックメソッドまたは関数を登録する必要がある
* 登録した描画用のスタティックメソッドまたは関数は、アドオン無効化時に ```bpy.types.SpaceXXX.draw_handler_remove()``` 関数を用いて、登録を解除する必要がある
* Blenderで開いているエリア情報は、```context.screen.areas``` から取得することができる
* ```blf.enable()``` により描画するテキストにに様々な効果を付け加えることができるが、不要になった設定は ```blf.enable()``` 必ず無効化する必要がある
